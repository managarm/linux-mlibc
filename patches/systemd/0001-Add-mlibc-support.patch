From 95eabc5eaa1e20da8a515241706e61855a53ca5e Mon Sep 17 00:00:00 2001
From: Dennis Bonke <admin@dennisbonke.com>
Date: Thu, 29 Jan 2026 22:15:40 +0100
Subject: [PATCH 1/2] Add mlibc support

---
 meson.build                          |   9 +
 meson_options.txt                    |   2 +-
 src/basic/basic-forward.h            |   2 +-
 src/basic/format-util.h              |   2 +-
 src/include/mlibc/gnu/libc-version.h |   8 +
 src/include/mlibc/malloc.h           |  39 ++++
 src/include/mlibc/printf.h           |  27 +++
 src/libc/meson.build                 |   1 +
 src/libc/mlibc/meson.build           |   9 +
 src/libc/mlibc/printf.c              | 263 +++++++++++++++++++++++++++
 10 files changed, 359 insertions(+), 3 deletions(-)
 create mode 100644 src/include/mlibc/gnu/libc-version.h
 create mode 100644 src/include/mlibc/malloc.h
 create mode 100644 src/include/mlibc/printf.h
 create mode 100644 src/libc/mlibc/meson.build
 create mode 100644 src/libc/mlibc/printf.c

diff --git a/meson.build b/meson.build
index 4746146..a0cfb39 100644
--- a/meson.build
+++ b/meson.build
@@ -2107,6 +2107,15 @@ if get_option('libc') == 'musl'
         system_includes += include_directories('src/include/musl', is_system : true)
 endif
 
+if get_option('libc') == 'mlibc'
+        system_include_args = [
+                '-isystem', meson.project_build_root()  / 'src/include/mlibc',
+                '-isystem', meson.project_source_root() / 'src/include/mlibc',
+        ] + system_include_args
+
+        system_includes += include_directories('src/include/mlibc', is_system : true)
+endif
+
 basic_includes = [
         include_directories(
                 'src/basic',
diff --git a/meson_options.txt b/meson_options.txt
index 4ce3c7f..69c204d 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -404,7 +404,7 @@ option('ima', type : 'boolean',
 option('ipe', type : 'boolean',
        description : 'IPE support')
 
-option('libc', type : 'combo', choices : ['glibc', 'musl'],
+option('libc', type : 'combo', choices : ['glibc', 'musl', 'mlibc'],
        description : 'libc implementation to be used')
 option('acl', type : 'feature', deprecated : { 'true' : 'enabled', 'false' : 'disabled' },
        description : 'libacl support')
diff --git a/src/basic/basic-forward.h b/src/basic/basic-forward.h
index d26cc5f..c0dbb80 100644
--- a/src/basic/basic-forward.h
+++ b/src/basic/basic-forward.h
@@ -120,7 +120,7 @@ typedef struct SocketAddress SocketAddress;
  * having to include the full header that provides these constants. */
 
 /* glibc defines AT_FDCWD as -100, but musl defines it as (-100). */
-#ifdef __GLIBC__
+#if defined(__GLIBC__) || defined(__mlibc__)
 #define AT_FDCWD                -100
 #else
 #define AT_FDCWD                (-100)
diff --git a/src/basic/format-util.h b/src/basic/format-util.h
index ac7f7b2..71acd58 100644
--- a/src/basic/format-util.h
+++ b/src/basic/format-util.h
@@ -39,7 +39,7 @@ assert_cc(sizeof(gid_t) == sizeof(uint32_t));
 #  error Unknown timex member size
 #endif
 
-#ifdef __GLIBC__
+#if defined(__GLIBC__) || defined(__mlibc__)
 #  if SIZEOF_RLIM_T == 8
 #    define RLIM_FMT "%" PRIu64
 #  elif SIZEOF_RLIM_T == 4
diff --git a/src/include/mlibc/gnu/libc-version.h b/src/include/mlibc/gnu/libc-version.h
new file mode 100644
index 0000000..328b53e
--- /dev/null
+++ b/src/include/mlibc/gnu/libc-version.h
@@ -0,0 +1,8 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+#pragma once
+
+#include <stddef.h>
+
+static inline const char* gnu_get_libc_version(void) {
+        return "";
+}
diff --git a/src/include/mlibc/malloc.h b/src/include/mlibc/malloc.h
new file mode 100644
index 0000000..9d15d4b
--- /dev/null
+++ b/src/include/mlibc/malloc.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+#pragma once
+
+#include <errno.h>
+#include <stdio.h>
+
+/* struct mallinfo2 will be defined and struct mallinfo is converted to struct mallinfo2 in
+ * override/malloc.h. Hence, here we define struct mallinfo. */
+
+struct mallinfo {
+        int arena;    /* non-mmapped space allocated from system */
+        int ordblks;  /* number of free chunks */
+        int smblks;   /* number of fastbin blocks */
+        int hblks;    /* number of mmapped regions */
+        int hblkhd;   /* space in mmapped regions */
+        int usmblks;  /* always 0, preserved for backwards compatibility */
+        int fsmblks;  /* space available in freed fastbin blocks */
+        int uordblks; /* total allocated space */
+        int fordblks; /* total free space */
+        int keepcost; /* top-most, releasable (via malloc_trim) space */
+};
+
+static inline struct mallinfo mallinfo(void) {
+        return (struct mallinfo) {};
+}
+
+static inline int malloc_info(int options, FILE *stream) {
+        if (options != 0)
+                errno = EINVAL;
+        else
+                errno = EOPNOTSUPP;
+        return -1;
+}
+
+static inline int malloc_trim(size_t pad) {
+        return 0;
+}
+
+#include_next <malloc.h>
diff --git a/src/include/mlibc/printf.h b/src/include/mlibc/printf.h
new file mode 100644
index 0000000..aa53826
--- /dev/null
+++ b/src/include/mlibc/printf.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/* Copyright 2014 Emil Renner Berthing <systemd@esmil.dk> */
+#pragma once
+
+#include <stddef.h>
+
+enum {              /* C type: */
+        PA_INT,     /* int */
+        PA_CHAR,    /* int, cast to char */
+        PA_WCHAR,   /* wide char */
+        PA_STRING,  /* const char *, a '\0'-terminated string */
+        PA_WSTRING, /* const wchar_t *, wide character string */
+        PA_POINTER, /* void * */
+        PA_FLOAT,   /* float */
+        PA_DOUBLE,  /* double */
+        PA_LAST,
+};
+
+/* Flag bits that can be set in a type returned by `parse_printf_format'.  */
+#define PA_FLAG_MASK        0xff00
+#define PA_FLAG_LONG_LONG   (1 << 8)
+#define PA_FLAG_LONG_DOUBLE PA_FLAG_LONG_LONG
+#define PA_FLAG_LONG        (1 << 9)
+#define PA_FLAG_SHORT       (1 << 10)
+#define PA_FLAG_PTR         (1 << 11)
+
+size_t parse_printf_format(const char *fmt, size_t n, int *types);
diff --git a/src/libc/meson.build b/src/libc/meson.build
index 306512f..1cf6169 100644
--- a/src/libc/meson.build
+++ b/src/libc/meson.build
@@ -17,6 +17,7 @@ libc_wrapper_sources = files(
 )
 
 subdir('musl')
+subdir('mlibc')
 
 sources += libc_wrapper_sources
 
diff --git a/src/libc/mlibc/meson.build b/src/libc/mlibc/meson.build
new file mode 100644
index 0000000..c94d9b5
--- /dev/null
+++ b/src/libc/mlibc/meson.build
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: LGPL-2.1-or-later
+
+if get_option('libc') != 'mlibc'
+        subdir_done()
+endif
+
+libc_wrapper_sources += files(
+        'printf.c',
+)
diff --git a/src/libc/mlibc/printf.c b/src/libc/mlibc/printf.c
new file mode 100644
index 0000000..6be5733
--- /dev/null
+++ b/src/libc/mlibc/printf.c
@@ -0,0 +1,263 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/* Copyright 2014 Emil Renner Berthing <systemd@esmil.dk> */
+
+#include <limits.h>
+#include <printf.h>
+#include <stdint.h>
+#include <string.h>
+
+static const char* consume_nonarg(const char *fmt) {
+        do {
+                if (*fmt == '\0')
+                        return fmt;
+        } while (*fmt++ != '%');
+        return fmt;
+}
+
+static const char* consume_num(const char *fmt) {
+        for (;*fmt >= '0' && *fmt <= '9'; fmt++)
+                /* do nothing */;
+        return fmt;
+}
+
+static const char* consume_argn(const char *fmt, size_t *arg) {
+        const char *p = fmt;
+        size_t val = 0;
+
+        if (*p < '1' || *p > '9')
+                return fmt;
+        do {
+                val = 10*val + (*p++ - '0');
+        } while (*p >= '0' && *p <= '9');
+
+        if (*p != '$')
+                return fmt;
+        *arg = val;
+        return p+1;
+}
+
+static const char* consume_flags(const char *fmt) {
+        for (;;)
+                switch (*fmt) {
+                case '#':
+                case '0':
+                case '-':
+                case ' ':
+                case '+':
+                case '\'':
+                case 'I':
+                        fmt++;
+                        continue;
+                default:
+                        return fmt;
+                }
+}
+
+enum state {
+        BARE,
+        LPRE,
+        LLPRE,
+        HPRE,
+        HHPRE,
+        BIGLPRE,
+        ZTPRE,
+        JPRE,
+        STOP,
+};
+
+enum type {
+        NONE,
+        PTR,
+        STR,
+        WSTR,
+        INT,
+        SHORT,
+        LONG,
+        LLONG,
+        IMAX,
+        SIZET,
+        CHAR,
+        WCHAR,
+        DBL,
+        LDBL,
+        NPTR,
+        _TYPE_MAX,
+};
+
+static const short pa_types[_TYPE_MAX] = {
+        [NONE]   = PA_INT,
+        [PTR]    = PA_POINTER,
+        [STR]    = PA_STRING,
+        [WSTR]   = PA_WSTRING,
+        [INT]    = PA_INT,
+        [SHORT]  = PA_INT | PA_FLAG_SHORT,
+        [LONG]   = PA_INT | PA_FLAG_LONG,
+#if ULLONG_MAX > ULONG_MAX
+        [LLONG]  = PA_INT | PA_FLAG_LONG_LONG,
+#else
+        [LLONG]  = PA_INT | PA_FLAG_LONG,
+#endif
+#if UINTMAX_MAX > ULONG_MAX
+        [IMAX]   = PA_INT | PA_FLAG_LONG_LONG,
+#elif UINTMAX_MAX > UINT_MAX
+        [IMAX]   = PA_INT | PA_FLAG_LONG,
+#else
+        [IMAX]   = PA_INT,
+#endif
+#if SIZE_MAX > ULONG_MAX
+        [SIZET]  = PA_INT | PA_FLAG_LONG_LONG,
+#elif SIZE_MAX > UINT_MAX
+        [SIZET]  = PA_INT | PA_FLAG_LONG,
+#else
+        [SIZET]  = PA_INT,
+#endif
+        [CHAR]   = PA_CHAR,
+        [WCHAR]  = PA_WCHAR,
+        [DBL]    = PA_DOUBLE,
+        [LDBL]   = PA_DOUBLE | PA_FLAG_LONG_DOUBLE,
+        [NPTR]   = PA_FLAG_PTR,
+};
+
+#define S(x) [(x)-'A']
+#define E(x) (STOP + (x))
+
+static const unsigned char states[]['z'-'A'+1] = {
+        { /* 0: bare types */
+                S('d') = E(INT),    S('i') = E(INT),
+                S('o') = E(INT),    S('u') = E(INT),    S('x') = E(INT),    S('X') = E(INT),
+                S('e') = E(DBL),    S('f') = E(DBL),    S('g') = E(DBL),    S('a') = E(DBL),
+                S('E') = E(DBL),    S('F') = E(DBL),    S('G') = E(DBL),    S('A') = E(DBL),
+                S('c') = E(CHAR),   S('C') = E(WCHAR),
+                S('s') = E(STR),    S('S') = E(WSTR),   S('p') = E(PTR),
+                S('n') = E(NPTR),
+                S('m') = E(NONE),
+                S('l') = LPRE,      S('q') = LLPRE,     S('h') = HPRE,      S('L') = BIGLPRE,
+                S('z') = ZTPRE,     S('Z') = ZTPRE,     S('j') = JPRE,      S('t') = ZTPRE,
+        },
+        { /* 1: l-prefixed */
+                S('d') = E(LONG),   S('i') = E(LONG),
+                S('o') = E(LONG),   S('u') = E(LONG),   S('x') = E(LONG),   S('X') = E(LONG),
+                S('e') = E(DBL),    S('f') = E(DBL),    S('g') = E(DBL),    S('a') = E(DBL),
+                S('E') = E(DBL),    S('F') = E(DBL),    S('G') = E(DBL),    S('A') = E(DBL),
+                S('c') = E(CHAR),   S('s') = E(STR),
+                S('n') = E(NPTR),
+                S('l') = LLPRE,
+        },
+        { /* 2: ll-prefixed */
+                S('d') = E(LLONG),  S('i') = E(LLONG),
+                S('o') = E(LLONG),  S('u') = E(LLONG),  S('x') = E(LLONG),  S('X') = E(LLONG),
+                S('n') = E(NPTR),
+        },
+        { /* 3: h-prefixed */
+                S('d') = E(SHORT),  S('i') = E(SHORT),
+                S('o') = E(SHORT),  S('u') = E(SHORT),  S('x') = E(SHORT),  S('X') = E(SHORT),
+                S('n') = E(NPTR),
+                S('h') = HHPRE,
+        },
+        { /* 4: hh-prefixed */
+                S('d') = E(CHAR),   S('i') = E(CHAR),
+                S('o') = E(CHAR),   S('u') = E(CHAR),   S('x') = E(CHAR),   S('X') = E(CHAR),
+                S('n') = E(NPTR),
+        },
+        { /* 5: L-prefixed */
+                S('e') = E(LDBL),   S('f') = E(LDBL),   S('g') = E(LDBL),   S('a') = E(LDBL),
+                S('E') = E(LDBL),   S('F') = E(LDBL),   S('G') = E(LDBL),   S('A') = E(LDBL),
+        },
+        { /* 6: z- or t-prefixed (assumed to be same size) */
+                S('d') = E(SIZET),  S('i') = E(SIZET),
+                S('o') = E(SIZET),  S('u') = E(SIZET),  S('x') = E(SIZET),  S('X') = E(SIZET),
+                S('n') = E(NPTR),
+        },
+        { /* 7: j-prefixed */
+                S('d') = E(IMAX),   S('i') = E(IMAX),
+                S('o') = E(IMAX),   S('u') = E(IMAX),   S('x') = E(IMAX),   S('X') = E(IMAX),
+                S('n') = E(NPTR),
+        },
+};
+
+size_t parse_printf_format(const char *fmt, size_t n, int *types) {
+        size_t i = 0;
+        size_t last = 0;
+
+        memset(types, 0, n);
+
+        for (;;) {
+                size_t arg;
+
+                fmt = consume_nonarg(fmt);
+                if (*fmt == '\0')
+                        break;
+                if (*fmt == '%') {
+                        fmt++;
+                        continue;
+                }
+                arg = 0;
+                fmt = consume_argn(fmt, &arg);
+                /* flags */
+                fmt = consume_flags(fmt);
+                /* width */
+                if (*fmt == '*') {
+                        size_t warg = 0;
+                        fmt = consume_argn(fmt+1, &warg);
+                        if (warg == 0)
+                                warg = ++i;
+                        if (warg > last)
+                                last = warg;
+                        if (warg <= n && types[warg-1] == NONE)
+                                types[warg-1] = INT;
+                } else
+                        fmt = consume_num(fmt);
+                /* precision */
+                if (*fmt == '.') {
+                        fmt++;
+                        if (*fmt == '*') {
+                                size_t parg = 0;
+                                fmt = consume_argn(fmt+1, &parg);
+                                if (parg == 0)
+                                        parg = ++i;
+                                if (parg > last)
+                                        last = parg;
+                                if (parg <= n && types[parg-1] == NONE)
+                                        types[parg-1] = INT;
+                        } else {
+                                if (*fmt == '-')
+                                        fmt++;
+                                fmt = consume_num(fmt);
+                        }
+                }
+                /* length modifier and conversion specifier */
+                unsigned state = BARE;
+                for (;;) {
+                        unsigned char c = *fmt;
+
+                        if (c == '\0')
+                                break;
+
+                        fmt++;
+
+                        if (c < 'A' || c > 'z')
+                                break;
+
+                        state = states[state]S(c);
+                        if (state == 0 || state >= STOP)
+                                break;
+                }
+
+                if (state <= STOP) /* %m or invalid format */
+                        continue;
+
+                if (arg == 0)
+                        arg = ++i;
+                if (arg > last)
+                        last = arg;
+                if (arg <= n)
+                        types[arg-1] = state - STOP;
+        }
+
+        if (last > n)
+                last = n;
+        for (i = 0; i < last; i++)
+                types[i] = pa_types[types[i]];
+
+        return last;
+}
-- 
2.51.0

